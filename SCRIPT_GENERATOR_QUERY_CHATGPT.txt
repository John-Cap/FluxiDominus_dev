Some classes:

from Core.Components import Pump


class PumpFlowrates:
    def __init__(self) -> None:
        self.pumps={}
        self.groups={}
        self.pumpGroups={}
        self.globalCumulative=30 #TODO - Hardcoded
        
        self._groupCounter=1
        
    def shiftKeepCumulative(self,pumpFlowrates={},snapToMinMax=True):
        groups=[]
        pumps=pumpFlowrates.keys
        #TODO - check if sum is below globalCumulative
        for x in pumps:
            if not self.pumpGroups[x] in groups:
                groups.append(self.pumpGroups[x])
        for grp in groups:
            grpPmps=self.groups[grp]
            frUsed=0
            frAvail=self.groupCumulativeFlowrate(grp)
            notAltered=[]
            maxGrpCumulative=self.allowedMaxCumulative()
            minGrpCumulative=self.allowedMinCumulative()
            for pmp in grpPmps:
                if pmp.pumpName in pumpFlowrates:
                    fr=pmp.flowrate
                    if frUsed > frAvail: #TODO - Not enough fr left!
                        pass
                        if fr <= self.pumpLimits[1] and fr >= self.pumpLimits[0]:
                            pass
                        elif snapToMinMax and fr <= pmp.flowrateMax:
                            pass
                        elif snapToMinMax and fr >= pmp.flowrateMin:
                            pass
                    elif frAvail >= fr:
                        if fr <= pmp.flowrateMax and fr >= pmp.flowrateMin:
                            pmp.flowrate=fr
                        elif snapToMinMax and fr >= pmp.flowrateMax:
                            pmp.flowrate=pmp.flowrateMax
                        elif snapToMinMax and fr <= pmp.flowrateMin:
                            pmp.flowrate=pmp.flowrateMin
                    frUsed+=pmp.flowrate
                    frAvail-=pmp.flowrate
                else:
                    del pumpFlowrates[pmp.pumpName]
            if len(pumpFlowrates)==0:
                return self.groupCumulativeFlowrate(grp)
            div=frAvail/(len(pumpFlowrates))
            for pmp in notAltered:
                pmp.flowrate=div
            return self.groupCumulativeFlowrate(grp)
                            
    def addPump(self,deviceName,settingName,pumpName=None,pumpAlias="",pumpGroup=None,pumpLimits=[None,None],pressureMax=None):
        
        pump=Pump(deviceName,settingName,pumpName=pumpName,flowrateMin=pumpLimits[0],flowrateMax=pumpLimits[1],pressureMax=pressureMax,pumpName=pumpName,pumpAlias=pumpAlias)

        if (not pumpGroup):
            self.addPumpGroup(groupName=pumpGroup,pumps=[pump])
        else:
            if not pumpGroup in self.groups:
                self.addPumpGroup(pumpGroup,pumps=[pump])
            else:
                self.groups[pumpGroup].append(pump)
            
        self.pumpLimits[pumpName]=pumpLimits
        self.pumpGroups[pumpName]=pumpGroup
        self.pumps[pumpName]=pump
        
        return pump
        
    def addPumpGroup(self,groupName=None,pumps=[],allowedMaxCumulative=None,adhereToAllowedMaxCumulative=True):
        
        if (not groupName):
            groupName="pumpGroup_"+self._groupCounter
            self._groupCounter+=1

        self.groups[groupName]=pumps
    
        if allowedMaxCumulative == 0:
            allowedMaxCumulative=None
        self.maxGroupCumulatives[groupName]=allowedMaxCumulative
            
        self.adhereToGroupCumulative[groupName]=adhereToAllowedMaxCumulative
        
    def groupCumulativeFlowrate(self,group):
        if group in self.groups:
            cum=0
            pumps=self.groups[group]
            for pmp in pumps:
                cum+=pmp.flowrate
            return cum
        else:
            return None
                
    def allowedMaxCumulative(self,group):
        if group in self.groups:
            cum=0
            pumps=self.groups[group]
            for pmp in pumps:
                cum+=pmp.flowrateMax
            return cum
        else:
            return None
        
    def allowedMinCumulative(self,group):
        if group in self.groups:
            cum=0
            pumps=self.groups[group]
            for pmp in pumps:
                cum+=pmp.flowrateMin
            return cum
        else:
            return None
                
    def setDesiredMaxCumulative(self,group,flowrate,snapTo=True):
        if not group in self.groups:
            return None
        min=self.allowedMinCumulative(group)
        max=self.allowedMaxCumulative(group)
        self.maxCumulativesSet[group]=None
        
        if min <= flowrate and max >= flowrate:
            self.maxCumulativesSet[group]=flowrate
        else:
            if min >= flowrate and snapTo:
                self.maxCumulativesSet[group]=min
            elif max <= flowrate and snapTo:
                self.maxCumulativesSet[group]=max
                
        return self.maxCumulativesSet[group]

class PumpBase:
    def __init__(self,deviceName,settingName,pumpName=None,pumpAlias="",flowrateMax = None,flowrateMin = None,pressureMax = None) -> None:
        self.deviceName=deviceName
        self.settingName=settingName
        self.pumpAlias=pumpAlias
        self.flowrate = 0
        self.flowrateMax = flowrateMax
        self.flowrateMin = flowrateMin
        self.pressureMax = pressureMax #TODO - Class Pressure
        self.status = False #TODO - false -> off, true -> available
        
        if not pumpName:
            self.pumpName=deviceName + "_" + settingName

    def setFlowrate(self,rate):
        self.flowrate = rate

class Pump(PumpBase):
    def __init__(self, deviceName, settingName, pumpName=None, pumpAlias="", flowrateMax=None, flowrateMin=None, pressureMax=None) -> None:
        super().__init__(deviceName, settingName, pumpName, pumpAlias, flowrateMax, flowrateMin, pressureMax)

Write a __main__ function that tests some stuff for class PumpFlowrates only :)