
This is a rig for monitoring optimizations, generating recommended parameters, and executing the commands.
See if you can complete the class OptimizationRig

from Config.Data.hardcoded_command_templates import HardcodedCommandTemplates
from Core.Control.ScriptGenerator import FlowChemAutomation
from Core.parametres.reaction_parametres import ReactionParametres

class OptimizationRig:
    def __init__(self,mqttService):
        self.automation = FlowChemAutomation() #handles command parsing
        self.reactionParametres=ReactionParametres() #Holds different parametres that can be optimized
        self.availableParams={} #Reaction parameters that can be tweaked, per device
        self.availableCmnds={} #Links a tweakable parameter to a specific device command name
        self.availableDeviceCmnds={} #Links device to commands
        self.currentRecommendation={}
        self.recommendationHistory=[]
        self._rigThread=None
        self.optimizer=None
        self.optimizing=False
        self.objectiveEvaluator=None
        
        self.mqttService=mqttService
    
    def registerDevice(self,device):
        """
        For example: "hotcoil1", "flowsynmaxi2", etc
        """
        if device in self.automation.commandTemplatesNested:
            #TODO - Unneccessary - this info is in self.automation
            self.availableDeviceCmnds=self.cmndTemplates[device] #Automatically stores available commands
        else:
            print(f'WJ - Unknown device {device}!')

    def registerTweakableParam(self,device,parameter):
        self.reactionParametres.addTweakable(parameter)
        if device in self.availableParams:
            self.availableParams[deviceName].append(parameter)
        else:
            self.availableParams[deviceName]=[]
            self.availableParams[deviceName].append(parameter)

    def generateRecommendation(self):
        """
        1. outputs a recommended parameter dict, linked to specific devices, stored in self.currentRecommendation
        2. All 
        3. A device can have multiple commands to execute, recommendation format eg:
            self.currentRecommendation={
                "hotcoil1":{
                    Temp.id as key:numerical value
                }
                "flowsynmaxi2":{
                    Flowrate.id as key:numerical value,
                    Flowrate.id as key:numerical value (Flowsyn has 2x flowrates to tweak)
                },
                ...
            }
        4. Store in self.currentRecommendation and invoke 'self.executeRecommendation'
        """
        pass
            
    def generateRecommendationMOCK(self):
        """
        generate random recommendations in 
        """
        pass
            
    def generateRecommendation(self):
        """
        generate random recommendations in 
        """
        pass
            
    def generateRecommendationMOCK(self):
        """
        generate random recommendations in 
        """
        pass
                        
    def executeRecommendation(self):
        """
        executes recommended parameter dict, ends by setting self.mqttService.script.
        1. From self.currentRecommendation, per 'device' key, commands are built up
        2. Each tweakable has a tweakable.associatedCommand property.
        3. First, self.automation.reset() is invoked
        4. Then, self.automation.addBlockElement() is invoked for each of a device's recommendations. For example:
            The entry in self.currentRecommendation "flowsynmaxi2" (the 'device')
            "flowsynmaxi2":{ #(Flowsyn has 2x flowrates to tweak)
                Flowrate.id as key:numerical value,
                Flowrate.id as key:numerical value
            },
            has self.automation.addBlockElement(Flowrate.name,device,Flowrate.associatedCommand,numerical value) invoked for each tweakable
        5. Then, self.automation.parseToScript() is invoked
        6. Then set self.mqttService.script=self.automation.output
        7. You're done!
        """
        
        #First clear current automation
        self.automation.reset()
    
    def start(self):
        """
        start thread
        """
        pass

Auxillary classes, do not modify:

#Base class
class ReactionParametre:
    def __init__(self, name, associatedCommand, ranges=None):
        self.id = uuid.uuid4()
        self.name = name
        self.ranges = {} if ranges is None else ranges  # Store ranges in a dictionary
        self.currentRange = []  # Stores the currently active range
        self._rangeCntr = 0  # Internal counter for tracking range indexes
        self.associatedCommand = associatedCommand

    def setRange(self, range):
        """
        Sets a range for the parameter. The range can be:
        - A simple list: [lowerBound, upperBound]
        - A list of lists: [[lowerBound1, upperBound1], [lowerBound2, upperBound2], ...]
        """
        if isinstance(range, list):
            if all(isinstance(i, list) and len(i) == 2 for i in range):
                # If given a list of lists, store each range separately
                for r in range:
                    self.ranges[self._rangeCntr] = r
                    self._rangeCntr += 1
            elif len(range) == 2:
                # If given a single range, store it
                self.ranges[self._rangeCntr] = range
                self._rangeCntr += 1
            else:
                raise ValueError("Invalid range format. Must be [lower, upper] or [[lower, upper], ...].")
        else:
            raise TypeError("Range must be a list.")

    def getRanges(self):
        """Returns a list of all stored ranges."""
        return list(self.ranges.values())

    def getCurrentRange(self):
        """Returns the currently active range if set, otherwise the first stored range."""
        if self.currentRange:
            return self.currentRange
        elif self.ranges:
            return self.ranges[0]  # Default to first range if no specific range is set
        return None

    def setCurrentRange(self, index):
        """
        Sets the current active range by index.
        """
        if index in self.ranges:
            self.currentRange = self.ranges[index]
        else:
            raise IndexError(f"Invalid range index {index}. Available indices: {list(self.ranges.keys())}")


class Temp(ReactionParametre):
    def __init__(self, name, associatedCommand, ranges=None):
        super().__init__(name, associatedCommand, ranges)
class ResidenceTime(ReactionParametre):
    def __init__(self, name, associatedCommand, ranges=None):
        super().__init__(name, associatedCommand, ranges)
class Flowrate(ReactionParametre):
    def __init__(self, name, associatedCommand, ranges=None):
        super().__init__(name, associatedCommand, ranges)
class Equivalents(ReactionParametre):
    def __init__(self, name, associatedCommand, ranges=None):
        super().__init__(name, associatedCommand, ranges)
        