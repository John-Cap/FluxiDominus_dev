
This is various classes involved in sending commands via MQTT inside the main loop. Observe custom commands such as "Delay", sometimes included in parsed scripts:

"{...'deviceName': 'sf10Vapourtec1', 'inUse': True, 'settings': {'command': 'SET', 'mode': 'FLOW', 'flowrate': 1}, 'topic': 'subflow/sf10vapourtec1/cmnd', 'client': <paho.mqtt.client.Client object at 0x000002546BDA2540>}, {'Delay': <Core.Control.Commands.Delay object at 0x000002546DE30BF0>},...]"

Note how 'Delay' is parsed, prepared, and how it achieves its effect in '.sendMQTT'

For the sister command 'WaitUntil', I need an example of it working and seeing if I can pass a function pointer and some params to make it work. Suggest a simple function that returns true if a param number is 1.
Background information:

class Procedure:
    def __init__(self,device="",sequence=[]) -> None:
        self.sequence=sequence #array of items
        self.device=device
        self.currItemIndex=0 #index of current instruction
        self.completed=False

    def setSequence(self,sequence):
        self.sequence=sequence

    def next(self):
        self.currItemIndex+=1

    def currConfiguration(self):
        if len(self.sequence) == self.currItemIndex:
            return None
        return self.sequence[self.currItemIndex]

    def currItemComplete(self,**kwargs):
        _thisItem=self.sequence[self.currItemIndex]
        _return=(_thisItem.isComplete(self.device,**kwargs))
        if _return:
            if (self.currItemIndex + 1) != len(self.sequence):
                self.currItemIndex=self.currItemIndex + 1
            else:
                self.currItemIndex = -2
                self.completed = True
            return _return
        else:
            return False

    def executeNext(self):
        pass

    def execute(self):
        pass

class Configuration:
    def __init__(self,commands,setMessage="Configuration set") -> None:
        self.devices=[]
        self.commands=commands
        self.setMessage=setMessage

    def sendAndSet(self):
        if (len(self.commands))==0:
            return
        if isinstance(self.commands[0],Delay):
            if (self.commands[0]).elapsed():
                del self.commands[0]
                return
            else:
                return
        elif isinstance(self.commands[0],WaitUntil):
            if (self.commands[0]).check():
                del self.commands[0]
                return
            else:
                return
        else:
            _io=IO()
            _io.write(json.dumps(self.commands[0]))
            sys.stdout.flush()
            del self.commands[0]

    def sendMQTT(self,waitForDelivery=False):
        if (len(self.commands))==0:
            return
        _currentCommand=(self.commands[0])
        if "Delay" in _currentCommand:
            if _currentCommand["Delay"].elapsed():
                del self.commands[0]
                return
            else:
                return
        elif "WaitUntil" in _currentCommand:
            if _currentCommand.check():
                del self.commands[0]
                return
            else:
                return
        else:
            _topic=_currentCommand["topic"]
            _client=_currentCommand["client"]
            if not _client.is_connected():
                _client.connect("localhost",1883)
            del _currentCommand["topic"]
            del _currentCommand["client"]
            _result=_client.publish(_topic,json.dumps(_currentCommand))
            if waitForDelivery:
                _result.wait_for_publish(5)
                #print(_result.is_published())
            del self.commands[0]
            #return _result

class Delay:
    def __init__(self,sleepTime=1,initTimestamp=None):
        self.sleepTime=sleepTime
        self.initTimestamp=initTimestamp
    def elapsed(self):
        if self.initTimestamp is None:
            self.initTimestamp=time.time()
        current_time = time.time()
        elapsed_time = current_time - self.initTimestamp
        return elapsed_time > self.sleepTime

class WaitUntil:
    def __init__(self,condition,timeout=60,initTimestamp=datetime.now().time(),completionMessage="WaitUntil complete"):
        self.condition=condition
        self.timeout=timeout
        self.initTimestamp=initTimestamp
        self.completionMessage=completionMessage
    def check(self):
        return self.condition.check()

***MAIN LOOP CONTAINING CONFIGURATION SWITCHING ETC

class FdpDecoder:
    def __init__(self, currKwargs=None,confNum=0):
        self.currKwargs = currKwargs if currKwargs else {}
        self.decoderClasses = {
            "Delay": self._decodeDelay,
            "WaitUntil": self._decodeWaitUntil,
            "FlowPathAdjustment": self._decodeFlowPathAdjustment,
        }
        self.confNum=confNum

    def _decodeDelay(self, data):
        print("_decodeDelay data: " + str (data))
        return Delay(initTimestamp=data["initTimestamp"], sleepTime=data["sleepTime"])

    def _decodeWaitUntil(self, data):
        return WaitUntil(
            condition=data["condition"],
            timeout=data["timeout"],
            initTimestamp=data["initTimestamp"],
            completionMessage=data["completionMessage"]
        )

    def _decodeFlowPathAdjustment(self, data):
        instance = self.currKwargs.get(data["instance"])
        attributeName = self.currKwargs.get(data["attributeName"], data["attributeName"])
        valueOrMethod = self.currKwargs.get(data["valueOrMethod"])
        args = self.currKwargs.get(data["args"], [])
        return FlowPathAdjustment(instance, attributeName, valueOrMethod, args)

    def decode(self, obj):
        if isinstance(obj, dict):
            for key, value in obj.items():
                if key in self.decoderClasses:
                    return self.decoderClasses[key](value)
        return obj

class ScriptParser:
    def __init__(self, script, client, confNum=0):
        self.client = client
        self.script = self._removeComments(script)
        self.blocks = self._parseScript()
        self.decoderClasses = {
            "Delay": Delay,
            "WaitUntil": WaitUntil,
            "FlowPathAdjustment": FlowPathAdjustment,
            "client": client,
        }
        self.confNum=confNum
        
    def convertJsonToPython(string):
        replacements = {
            "true": "True",
            "false": "False",
            "null": "None"
        }
        for jsonValue, pythonValue in replacements.items():
            string = string.replace(jsonValue, pythonValue)
        return string

    def _removeComments(self, text):
        pattern = r"/\*.*?\*/"
        return re.sub(pattern, "", text, flags=re.DOTALL)

    def _parseScript(self):
        blocks = {}
        currentBlock = None

        for line in self.script.split(';'):
            line = line.strip()
            if '=' in line:
                blockName, blockContent = line.split('=', 1)
                blockName = blockName.strip()
                if blockContent.startswith('[') and blockContent.endswith(']'):
                    blockContent = blockContent[1:-1].strip()  # Remove the outer brackets and trim whitespace
                    try:
                        parsedBlock = ast.literal_eval(f'[{blockContent}]')
                        blocks[blockName] = parsedBlock
                        currentBlock = blockName
                    except Exception as e:
                        print(f"Error parsing block {blockName}: {e}")
                else:
                    currentBlock = None
            elif currentBlock and line.startswith('{') and line.endswith('}'):
                try:
                    parsedContent = ast.literal_eval(line)
                    blocks[currentBlock].append(parsedContent)  # Append additional JSON objects to current block
                except Exception as e:
                    print(f"Error parsing additional block content: {e}")
        
        return blocks

    def convertToNodeScripts(self, blockName, blockContent, fdpDecoder):
        nodeScripts = []
        for entry in blockContent:
            processedEntry = self._processEntry(entry, fdpDecoder)
            nodeScripts.append(processedEntry)
        return nodeScripts

    def _processEntry(self, entry, fdpDecoder):
        for key in entry:
            if key in self.decoderClasses:
                entry[key] = fdpDecoder.decode({key: entry[key]})
            if key == "client":
                entry[key] = self.client
        print(entry)
        return entry
    
    def createProcedure(self, fdpDecoder):
        configurations = []
        for blockName, blockContent in self.blocks.items():
            nodeScripts = self.convertToNodeScripts(blockName, blockContent, fdpDecoder)
            configurations.append(Configuration(nodeScripts,setMessage=("Config " + str(self.confNum) + " is complete!")))
            self.confNum+=1
        return Procedure(sequence=configurations)

Note I don't want to change too much in terms of existing code