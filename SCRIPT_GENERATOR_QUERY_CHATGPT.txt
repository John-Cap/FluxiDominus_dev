I'm not following. I labelled all mentions of FlowTerminus with (#) numbers, explain again:

    def advanceSlugs(self):
        if self.flowrateShifted:
            self.updateFlowrates()
            self.flowrateShifted = False

        _nowTime = time.perf_counter()
        _dT = _nowTime - self.timePrev
        self.timePrev = _nowTime

        if _dT <= 0:
            return

        if len(self.slugs) == 0: #Flowpath is homogenous
            return
        
        #Front movement
        for slug in self.slugs:
            _frontHost = slug.frontHost
            
            #If frontHost is None, no advancement
            if _frontHost is None:
                continue

            (1)
            #If slug has reached a terminus and is collecting
            if isinstance(_frontHost, FlowTerminus):
                if not slug.collected:
                    #Increase collected volume by input flow * dT
                    slug.collectedVol += _frontHost.flowrateIn * _dT
                    if slug.reachedTerminusAt == 0:
                        slug.reachedTerminusAt = _nowTime
                #No further advancement needed for a terminus
                continue
            
            #Check if outlet/inlets match and can actually flow forwards (TODO - Performance!)
            _nextHosts=_frontHost.outlets
            pathForward=False
            for x in _nextHosts:
                if _frontHost in x.inlets:
                    pathForward=True
                    break
            if not pathForward:
                continue
            
            #Calculate displacement volume for this timestep
            _dV = _frontHost.flowrateOut * _dT
            _newVol = slug.frontHostPos + _dV

            #Check if slug surpasses the current frontHost volume
            if _newVol > _frontHost.volume:
                #We have leftover volume after filling this component
                _remainder = _newVol - _frontHost.volume

                #Move to next host(s)
                #Compute initial leftover time at the moment slug left _frontHost
                _currHostLeftToFill = (_frontHost.volume - slug.frontHostPos)
                _frontHostFillTime = _currHostLeftToFill / _frontHost.flowrateOut
                _dTRemainder = _dT - _frontHostFillTime

                #Identify the next host
                if len(_frontHost.outlets) == 0:
                    #No next host, slug stops here
                    slug.frontHostPos = _frontHost.volume
                    continue

                _nextHost = _frontHost.outlets[0]

                #If flowrates differ between hosts, adjust volume based on the nextHost’s flowrate
                (2)
                if isinstance(_nextHost, FlowTerminus):
                    #If next host is a terminus, slug enters and is collected
                    slug.frontHost = _nextHost
                    #Adjust collectedVol by remainder
                    slug.collectedVol += _remainder
                    slug.frontHostPos = 0
                    slug.collecting = True
                else:
                    #If next host has a different flowrate
                    if _nextHost.flowrateOut != _frontHost.flowrateOut:
                        _volumeAdd = _dTRemainder * _nextHost.flowrateOut
                    else:
                        _volumeAdd = _remainder

                    #Now, potentially continue through multiple hosts
                    slug.frontHost = _nextHost
                    #Use a loop to handle multiple jumps
                    _stillToFill = _volumeAdd

                    while _stillToFill > _nextHost.volume:
                        #Surpass this host entirely
                        _stillToFill -= _nextHost.volume

                        #Move to the next outlet
                        if len(_nextHost.outlets) == 0:
                            #No further hosts, slug ends here
                            slug.frontHostPos = _nextHost.volume
                            break

                        _nextHost = _nextHost.outlets[0]

                        (3)
                        if isinstance(_nextHost, FlowTerminus):
                            #Slug enters terminus and is collected
                            slug.frontHost = _nextHost
                            slug.collectedVol += _stillToFill
                            slug.frontHostPos = 0
                            slug.collecting = True
                            _stillToFill = 0
                            break

                        #If next host differs in flowrate, we’d need additional logic here
                        #But for now we assume the computed _stillToFill works directly
                        slug.frontHost = _nextHost

                    #If we still have leftover that doesn't surpass the new host fully
                    if 0 < _stillToFill <= _nextHost.volume and not isinstance(_nextHost, FlowTerminus):
                        slug.frontHostPos = _stillToFill

            else:
                #Slug remains within the same host
                slug.frontHostPos = _newVol

        #Tail movement
        #Similar logic applies for the tail. We allow multiple host jumps if needed.
        for slug in self.slugs[:]:  #copy list since we may remove slugs
            _tailHost = slug.tailHost

            #If tail is in a terminus, slug is collected
            (4)
            if isinstance(_tailHost, FlowTerminus):
                if not slug.collected:
                    slug.collected = True
                    self.collectedSlugs.append(slug)
                    self.slugs.remove(slug)
                continue

            _dV = _tailHost.flowrateOut * _dT
            
            if _tailHost.dispensing:
                #Only dispense up to the remainder
                if _tailHost.remainderToDispense is not None:
                    if _dV > _tailHost.remainderToDispense:
                        #Cap _dV so we don't overshoot
                        _dV = _tailHost.remainderToDispense
                
                slug.totalDispensed += _dV

                if _tailHost.remainderToDispense is not None:
                    _tailHost.remainderToDispense -= _dV
                    if _tailHost.remainderToDispense <= 0:
                        _tailHost.dispensing = False
                        slug.dispensed=True
                        _tailHost.remainderToDispense = 0
                continue

            _tailHostPos = slug.tailHostPos
            _newVol = _tailHostPos + _dV

            #Check if we surpass the tailHost's volume
            if _newVol > _tailHost.volume:
                _remainder = _newVol - _tailHost.volume

                #Move on to next host
                if len(_tailHost.outlets) == 0:
                    #No further hosts, so slug remains here
                    slug.tailHostPos = _tailHost.volume
                    continue

                _nextHost = _tailHost.outlets[0]

                (5)
                if isinstance(_nextHost, FlowTerminus):
                    #Slug tail enters terminus - slug is collected
                    slug.tailHost = _nextHost
                    slug.tailHostPos = 0
                    self.collectedSlugs.append(slug)
                    self.slugs.remove(slug)
                else:
                    #Handle multiple jumps for the tail
                    _currHostLeftToFill = (_tailHost.volume - _tailHostPos)
                    _tailHostFillTime = _currHostLeftToFill / (_tailHost.flowrateOut)
                    _dTRemainder = _dT - _tailHostFillTime

                    if _nextHost.flowrateOut != _tailHost.flowrateOut:
                        _volumeAdd = _dTRemainder * _nextHost.flowrateOut
                    else:
                        _volumeAdd = _remainder

                    slug.tailHost = _nextHost
                    _stillToFill = _volumeAdd

                    while _stillToFill > _nextHost.volume:
                        _stillToFill -= _nextHost.volume
                        if len(_nextHost.outlets) == 0:
                            #No further hosts for the tail
                            slug.tailHostPos = _nextHost.volume
                            break

                        _nextHost = _nextHost.outlets[0]

                        (6)
                        if isinstance(_nextHost, FlowTerminus):
                            #Slug tail enters terminus
                            slug.tailHost = _nextHost
                            slug.tailHostPos = 0
                            self.collectedSlugs.append(slug)
                            if slug in self.slugs:
                                self.slugs.remove(slug)
                            _stillToFill = 0
                            break

                        slug.tailHost = _nextHost

                    if 0 < _stillToFill <= _nextHost.volume and not isinstance(_nextHost, FlowTerminus):
                        slug.tailHostPos = _stillToFill
            else:
                #Tail remains within the same host
                slug.tailHostPos = _newVol
